Your task is to generate the Binary Search Tree from a pre-order traversal of a BST. The pre-order will be of the form of an array of integers.



As discussed in the lecture, you have to take note of the following ways to reconstruct the BST:

The first element n will always be the root.
The next elements that are smaller than n will constitute its left subtree.
The rest of the elements will constitute its right subtree.


For example, the Test Case 1 uses the pre-order of 30 20 10 50 40. The first element 30 must be the root (the top node). Then, we locate its left subtree and these are the elements after it that are smaller than 30. In this case, we have 20 and 10. The rest of the elements must be the right subtree. Then to complete its left subtree, we consider the 20 10. Again, the first element 20 must be the top node, followed by the left subtree i.e. those smaller than 20, which is 10. There are no more elements so 20 has no right child. Then we can complete the left subtree of 20 where we consider the 10. The first element is 10 and it shall be the top node. There are no more elements after 10, so it must have no left and right child.



Given the explanation above, you should be able to solve this problem recursively. In the bst.h file, the method from_preorder is called from the main.cpp, given the array that contains the elements and the size of the array. This will set the size of the bst to the size of the array since it corresponds on the number of elements that will be placed in the tree. The next line assigns the tree's root to the result of the convert_preorder method given the following arguments: array, start, end, parent.

int* array - the same array that contains all the elements. This will remain unaltered and shall be passed constantly and unchanged.
int start
the starting index which it will consider. Initially passes 0 as argument since the first method call will consider everything from the first index.
int end
the last index which it will consider. Initially passes size-1 as argument since the first method call will consider everything to the last index.
node* parent
the parent node of the newly created node to be created. Initially passes *NULL *as argument since the root has no parent.


For your task, implement the convert_preorder in a recursive manner. You can use the following steps as your guide. This will also be explained by the instructor.

The start must be less than the end. So if it is not the case, return NULL.
Create the top node using tree->create_node(). In a preorder, that will always be found at the start. Also set its parent to the parent argument.
Find the start and the end of the left child and the right child. Note that the start of the left child will be one more than the start. The challenge here is to locate the end of the left child, since the start of the right child is one more than the end of the left child.
Recursively call the method for the left and right child given their start and end as mentioned in step 3. Also pass the node created in step 2 as the parent.
Assign the children of the node created in step 2 to the children in step 4.
Lastly, return the node created in step 2.


Limitations: You will NOT be allowed to manually insert the nodes using the tree's or the BST's insert method.

Sample Output 1

Enter size of array: 5
Enter pre-order: 30 20 10 50 40
Size: 5
+--R: 30
|   +--L: 20
|   |   +--L: 10
|   +--R: 50
|   |   +--L: 40
Status: 1
Sample Output 2

Enter size of array: 5
Enter pre-order: 30 10 20 40 50
Size: 5
+--R: 30
|   +--L: 10
|   |   +--R: 20
|   +--R: 40
|   |   +--R: 50
Status: 1
Sample Output 3

Enter size of array: 5
Enter pre-order: 30 20 10 40 50
Size: 5
+--R: 30
|   +--L: 20
|   |   +--L: 10
|   +--R: 40
|   |   +--R: 50
Status: 1